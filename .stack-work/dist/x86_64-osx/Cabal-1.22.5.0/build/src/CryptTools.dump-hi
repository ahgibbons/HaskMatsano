
==================== FINAL INTERFACE ====================
2016-06-01 23:59:30.137245 UTC

interface Matas_EL5oZZhIsKy82lR7fUB5AU:CryptTools 7103
  interface hash: 777567179e34a683f7bbe3ff21bd02e5
  ABI hash: 479cdd3a1a2f9d64f29339ca53dcd254
  export-list hash: 1c41cfbc89af9a6be5f984b69614a455
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 161d16d3422b284d74d35a691dea01b8
  sig of: Nothing
  used TH splices: False
  where
exports:
  CryptTools.b64List
  CryptTools.b64ListMap
  CryptTools.b64ListMapFlip
  CryptTools.charCountVector
  CryptTools.countChars
  CryptTools.eq_char
  CryptTools.joinBits
  CryptTools.letterFreqs
  CryptTools.letterPerc
  CryptTools.padd
  CryptTools.readB16
  CryptTools.showB16
  CryptTools.showB64
  CryptTools.showB64String
  CryptTools.showBin
  CryptTools.similarity
  CryptTools.splitBits
  CryptTools.xorChar
  CryptTools.B64String
  CryptTools.HexString
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 bitwise-0.1.1.1@bitwi_1UInExT1dkGBFQ7JfumA61
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      types-compat-0.1.1@types_4nbjkueFGIp963bsRkjZLR
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics base-4.8.2.0:GHC.TypeLits
                         bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW:Data.ByteString.Read.Class
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Numeric 7a5febcdaefe4560a31129dafeb9ee43
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  bitwise-0.1.1.1@bitwi_1UInExT1dkGBFQ7JfumA61:Data.Bits.Bitwise ccee56f8d406d69f235a496d42447bb2
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString effd24476ff7cd481cf047a616a25531
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Char8 893c19fbf58ee60a22fc906f46ccd8aa
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Internal 5277858ffbc0cf52849c8ef7e713c6ac
import  -/  bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW:Data.ByteString.Read 02bd44212b38953ca43babd46a186e62
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Strict 2e796f3ebd5f3ce783e00a01f5cdcaa8
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
2e370b105d9b6689170a2de57e4f2398
  $wpadd :: a -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a3 w :: a3 ww :: GHC.Prim.Int# w1 :: [a3] ->
                 let {
                   $j :: GHC.Prim.Int# -> [a3] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ x :: GHC.Prim.Int#[OneShot] ->
                     case x of wild {
                       DEFAULT
                       -> let {
                            y :: GHC.Prim.Int# = GHC.Prim.-# ww wild
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0 y) of wild1 {
                            GHC.Types.False -> w1
                            GHC.Types.True
                            -> let {
                                 lvl3 :: [a3] = GHC.Types.: @ a3 w w1
                               } in
                               letrec {
                                 $wxs2 :: GHC.Prim.Int# -> [a3]
                                   {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                 = \ ww1 :: GHC.Prim.Int# ->
                                   case ww1 of ds1 {
                                     DEFAULT -> GHC.Types.: @ a3 w ($wxs2 (GHC.Prim.-# ds1 1))
                                     1 -> lvl3 }
                               } in
                               $wxs2 y }
                       0 -> w1 }
                 } in
                 case ww of wild {
                   DEFAULT
                   -> case GHC.List.$wlenAcc @ a3 w1 0 of ww2 { DEFAULT ->
                      case GHC.Classes.modInt# ww2 wild of ww1 { DEFAULT -> $j ww1 } }
                   (-1) -> $j 0
                   0 -> case GHC.Real.divZeroError ret_ty [a3] of {} }) -}
c04fcb404725cb7020cf6a04907634ad
  $wxs :: GHC.Prim.Int# -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
301b5a5470ceacb17d3835d679f35612
  $wxs1 :: GHC.Prim.Int# -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
6e441a6f4982f510e21affc39030426c
  type B64String = Data.ByteString.Internal.ByteString
073d0baaf4a869ea98fb5fdbde5f2ded
  type HexString = Data.ByteString.Internal.ByteString
db6d980a6b5aa0092dbce0ae86e0d0b4
  b64List :: [GHC.Types.Char]
  {- Unfolding: (CryptTools.b64List_go 65) -}
168ad4ceaf6939e32d38926eea6c395b
  b64ListMap :: [(GHC.Types.Int, GHC.Types.Char)]
  {- Unfolding: (CryptTools.b64ListMap_go 0 CryptTools.b64List) -}
0cb992f2ce11824bd2410e8ad21accc1
  b64ListMapFlip :: [(GHC.Types.Char, GHC.Types.Int)]
  {- Unfolding: (GHC.List.zip
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   CryptTools.b64List
                   CryptTools.b64ListMapFlip1) -}
cea74231498a6c3c0596d310cab1d00c
  b64ListMapFlip1 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0 9223372036854775807) -}
bc71be17500b42ccde49d9aab52a1526
  b64ListMap_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Char)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
2ee7dc4c73caee981292d01d6081c14c
  b64List_go :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,U> -}
04d817f3c6e800e4f63f58494393cc68
  charCountVector ::
    GHC.Base.String
    -> [(GHC.Types.Char, GHC.Types.Int)] -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ alphabet :: GHC.Base.String
                   charCount :: [(GHC.Types.Char, GHC.Types.Int)] ->
                 GHC.Base.map
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   (\ y :: GHC.Types.Char ->
                    case GHC.List.lookup
                           @ GHC.Types.Char
                           @ GHC.Types.Int
                           GHC.Classes.$fEqChar
                           y
                           charCount of wild {
                      GHC.Base.Nothing -> CryptTools.charCountVector1
                      GHC.Base.Just n2 -> n2 })
                   alphabet) -}
e3d7a1913fbdeeb7ba5c50352e511a88
  charCountVector1 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0) -}
3db570481c567be0238a7864ea94fd64
  countChars ::
    GHC.Base.String
    -> GHC.Base.String -> [(GHC.Types.Char, GHC.Types.Int)]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ alphabet :: GHC.Base.String
                   string :: GHC.Base.String ->
                 GHC.Base.map
                   @ [GHC.Types.Char]
                   @ (GHC.Types.Char, GHC.Types.Int)
                   CryptTools.countChars1
                   (Data.OldList.groupBy
                      @ GHC.Types.Char
                      GHC.Classes.$fEqChar_$c==
                      (Data.OldList.sortBy
                         @ GHC.Types.Char
                         GHC.Classes.$fOrdChar_$ccompare
                         (GHC.List.filter
                            @ GHC.Types.Char
                            (\ ds :: GHC.Types.Char ->
                             GHC.List.elem @ GHC.Types.Char GHC.Classes.$fEqChar ds alphabet)
                            string)))) -}
9818256d54a42fcd5617d9f54a015a95
  countChars1 :: [GHC.Types.Char] -> (GHC.Types.Char, GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ cs :: [GHC.Types.Char] ->
                 (GHC.List.head @ GHC.Types.Char cs,
                  case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                  GHC.Types.I# ww2 })) -}
b42410e33654e3ea1bf58986ef36efa1
  eq_char :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 61) -}
a1aa0d5e300e15b44563a875cfeaed2b
  joinBits ::
    (GHC.Real.Integral a, GHC.Num.Num b, Data.Bits.Bits b) =>
    GHC.Types.Int -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><L,U(A,A,1*U,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U)><S,U>,
     Unfolding: (\ @ a3
                   @ b
                   $dIntegral :: GHC.Real.Integral a3
                   $dNum :: GHC.Num.Num b
                   $dBits :: Data.Bits.Bits b
                   byteshift :: GHC.Types.Int
                   wlist :: [a3] ->
                 case GHC.List.$wlenAcc @ a3 wlist 0 of ww2 { DEFAULT ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww2 1
                 } in
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 2
                 } in
                 let {
                   a4 :: b -> b -> b = Data.Bits..|. @ b $dBits
                 } in
                 let {
                   z :: b = GHC.Num.fromInteger @ b $dNum CryptTools.joinBits1
                 } in
                 let {
                   c :: GHC.Types.Int -> ([a3] -> b) -> [a3] -> b
                     {- Arity: 3, Strictness: <L,1*U(U)><L,1*C1(U)><S,1*U> -}
                   = \ _x :: GHC.Types.Int _r :: [a3] -> b[OneShot] ds :: [a3] ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> a4
                            (Data.Bits.shift
                               @ b
                               $dBits
                               (GHC.Num.fromInteger
                                  @ b
                                  $dNum
                                  (GHC.Real.toInteger @ a3 $dIntegral y))
                               (case byteshift of wild1 { GHC.Types.I# x ->
                                case _x of wild2 { GHC.Types.I# y1 ->
                                GHC.Types.I# (GHC.Prim.*# x y1) } }))
                            (_r ys) }
                 } in
                 let {
                   n2 :: [a3] -> b
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ ds :: [a3] -> z) -}
                   = \ ds :: [a3] -> z
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x2 x1) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB @ ([a3] -> b) c n2 x1 x2 0 wlist
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB @ ([a3] -> b) c n2 x1 x2 0 wlist } }) -}
a1e3e0cd2082fe2272e3acccca082199
  joinBits1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
d796afcc43e231669c78463c43a31a15
  joinBits_$sjoinBits ::
    GHC.Types.Int -> [GHC.Word.Word8] -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,U(U)><S,U>,
     Unfolding: (\ byteshift :: GHC.Types.Int
                   wlist :: [GHC.Word.Word8] ->
                 case GHC.List.$wlenAcc @ GHC.Word.Word8 wlist 0 of ww2 { DEFAULT ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww2 1
                 } in
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 2
                 } in
                 let {
                   c :: GHC.Types.Int
                        -> ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        -> [GHC.Word.Word8]
                        -> GHC.Integer.Type.Integer
                     {- Arity: 3, Strictness: <L,1*U(U)><L,1*C1(U)><S,1*U> -}
                   = \ _x :: GHC.Types.Int
                       _r :: [GHC.Word.Word8] -> GHC.Integer.Type.Integer[OneShot]
                       ds :: [GHC.Word.Word8] ->
                     case ds of wild {
                       [] -> CryptTools.joinBits1
                       : y ys
                       -> case y of wild1 { GHC.Word.W8# x# ->
                          case byteshift of wild2 { GHC.Types.I# x ->
                          case _x of wild3 { GHC.Types.I# y1 ->
                          let {
                            ww :: GHC.Prim.Int# = GHC.Prim.*# x y1
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# ww 0) of wild4 {
                            GHC.Types.False
                            -> GHC.Integer.Type.orInteger
                                 (GHC.Integer.Type.shiftRInteger
                                    (GHC.Integer.Type.smallInteger (GHC.Prim.word2Int# x#))
                                    (GHC.Prim.negateInt# ww))
                                 (_r ys)
                            GHC.Types.True
                            -> GHC.Integer.Type.orInteger
                                 (GHC.Integer.Type.shiftLInteger
                                    (GHC.Integer.Type.smallInteger (GHC.Prim.word2Int# x#))
                                    ww)
                                 (_r ys) } } } } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x2 x1) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        c
                        CryptTools.joinBits_n
                        x1
                        x2
                        0
                        wlist
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        c
                        CryptTools.joinBits_n
                        x1
                        x2
                        0
                        wlist } }) -}
3fcc65fe114e05abd6cc47f694c79313
  joinBits_n :: [GHC.Word.Word8] -> GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: [GHC.Word.Word8] -> CryptTools.joinBits1) -}
fe855771d01ca26ffb75693b1fd2472f
  letterFreqs :: [(GHC.Types.Char, GHC.Types.Double)]
  {- Unfolding: (CryptTools.letterFreqs_go
                   97
                   CryptTools.letterPerc) -}
c6b4cb355f7f738b50eba830648f55cc
  letterFreqs_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Double] -> [(GHC.Types.Char, GHC.Types.Double)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U> -}
6cd19ff503a9376799bac1d90850554c
  letterPerc :: [GHC.Types.Double]
  {- Unfolding: (GHC.Base.map
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   CryptTools.letterPerc53
                   CryptTools.letterPerc1) -}
30de1a9e0a31b858c4b2c42d0e135554
  letterPerc1 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc52
                   CryptTools.letterPerc2) -}
abc25eb6ba0ace48a83a1f3ab508e9cc
  letterPerc10 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc43
                   CryptTools.letterPerc11) -}
92ea1d8fc611a7a99ae540b5b6053891
  letterPerc11 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc42
                   CryptTools.letterPerc12) -}
2ba5fac92ebca4cf859b6f779d1dcdc5
  letterPerc12 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc41
                   CryptTools.letterPerc13) -}
5990fb3347e8e0b8699ce37cd3b53ac9
  letterPerc13 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc40
                   CryptTools.letterPerc14) -}
c160da3d551378b77cdc3cd59c77e806
  letterPerc14 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc39
                   CryptTools.letterPerc15) -}
6c6711a1af03e3303945abe9af8d5d48
  letterPerc15 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc38
                   CryptTools.letterPerc16) -}
d3eca02e4803f62fde2757fbc2736771
  letterPerc16 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc37
                   CryptTools.letterPerc17) -}
869ac9e7b06442b13f08deae1c1cd82e
  letterPerc17 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc36
                   CryptTools.letterPerc18) -}
aa4a8adfb02dfc0d0da9c85c83e058fb
  letterPerc18 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc35
                   CryptTools.letterPerc19) -}
f22c62c728aa25085e651f062b0d5b51
  letterPerc19 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc34
                   CryptTools.letterPerc20) -}
9fbd55f3f4ee703da828d5cd951e5d8d
  letterPerc2 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc51
                   CryptTools.letterPerc3) -}
7c5e744ae1741106aa1abcfd05915522
  letterPerc20 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc33
                   CryptTools.letterPerc21) -}
98e49ffc9d800f9296ae2769b903000d
  letterPerc21 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc32
                   CryptTools.letterPerc22) -}
0968388e2cd7d305840515100dd01a9a
  letterPerc22 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc31
                   CryptTools.letterPerc23) -}
f202afe2c1a86c3eca2599509c7f9491
  letterPerc23 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc30
                   CryptTools.letterPerc24) -}
31a2e708cd57c0603162ac18ff6dffa0
  letterPerc24 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc29
                   CryptTools.letterPerc25) -}
d20c27a5cfe41d73947787709711f4f8
  letterPerc25 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc28
                   CryptTools.letterPerc26) -}
b6e26fcba539b76c75465c9bc3b0d5d9
  letterPerc26 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc27
                   (GHC.Types.[] @ GHC.Types.Double)) -}
3818ccd9132552fb0dd14f6e65fd0074
  letterPerc27 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 7.4e-2) -}
1b4d30d77eecbd81a747f75caecff726
  letterPerc28 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.974) -}
422e74d516c9bcab323df38a1842b2cf
  letterPerc29 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.15) -}
55fb2029ec7c2e1c24f2483d61b1581f
  letterPerc3 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc50
                   CryptTools.letterPerc4) -}
475dcea2e1fb06771515bdfe6f8e3d54
  letterPerc30 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.361) -}
cc4dae33003962860436dd1aba6feede
  letterPerc31 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.978) -}
8b09361d5a40d47a75524f3911484e09
  letterPerc32 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.758) -}
5c1f6249e88970ee84eac62a7a6340dd
  letterPerc33 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 9.056) -}
1f1a21d98d6c913fad0b066bc7202d03
  letterPerc34 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.327) -}
56617cf2ada62c4ac26fb4a7cf425900
  letterPerc35 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 5.987) -}
1198a550bc34e7cba537cf85252b46de
  letterPerc36 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 9.5e-2) -}
5ccf4c0e56ae6ab76cec7828e2746166
  letterPerc37 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.929) -}
12494d4b6e7c2c50ee0872a01fb144b5
  letterPerc38 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 7.507) -}
c37628d3a44fe49c8cf4d4f1bcaf7dfd
  letterPerc39 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.749) -}
99e3a9c5cd7d08af3a5efffad19d4e69
  letterPerc4 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc49
                   CryptTools.letterPerc5) -}
28a8701e086185e728b0dbffc8913d31
  letterPerc40 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.406) -}
be90cbcf4abde076a9839eded596c5a6
  letterPerc41 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 4.025) -}
bafcd04caf302d3135a79e8a95023624
  letterPerc42 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.772) -}
588446074a1fca9685ca27fda8affe13
  letterPerc43 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.153) -}
e1d4bcea153430faa3f813a19932c52f
  letterPerc44 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.966) -}
3d4882c5a2de06cdc3498e5c25448a09
  letterPerc45 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.094) -}
b6def2a77f2a9854d223b25ee69086e6
  letterPerc46 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.015) -}
5d3947a630c058b4279373f307bb0789
  letterPerc47 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.228) -}
d8aeaa3948523d0299189ee81748c6bd
  letterPerc48 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 12.702) -}
073e2247bf8445c753e25639eef062a9
  letterPerc49 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 4.253) -}
d759449de45fa858a3e5d861bc760d9e
  letterPerc5 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc48
                   CryptTools.letterPerc6) -}
4a92a4ecbe837e1616bb200f5e106b79
  letterPerc50 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.782) -}
db6da217e8b8ac16e77ce13d6f3d7519
  letterPerc51 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.492) -}
a87810d071c7fa7b78873399105bb34a
  letterPerc52 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 8.167) -}
bfa5bf7bcd29e1e1eb391574b0e3da0e
  letterPerc53 :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ ds :: GHC.Types.Double ->
                 case ds of wild { GHC.Types.D# x ->
                 GHC.Types.D# (GHC.Prim./## x 100.0) }) -}
9b4a5dd60911428751b02e3f81a379be
  letterPerc6 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc47
                   CryptTools.letterPerc7) -}
0d8764ecef451ef77f273d8ee0b1cb94
  letterPerc7 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc46
                   CryptTools.letterPerc8) -}
618599ccd45ad79f7b28ecbd93153671
  letterPerc8 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc45
                   CryptTools.letterPerc9) -}
90702eae711d352239e1d2994b1c9c58
  letterPerc9 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc44
                   CryptTools.letterPerc10) -}
bda1bc6be8730730136a100e7f587327
  padd :: a -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a3 w :: a3 w1 :: GHC.Types.Int w2 :: [a3] ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 CryptTools.$wpadd @ a3 w ww1 w2 }) -}
1cee73538c47df25c88b02dad24d9b10
  readB1 :: GHC.Integer.Type.Integer
  {- Strictness: b -}
f27af5882304a4e9c6b5340985165948
  readB16 :: CryptTools.HexString -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <L,1*U(U,U,U,U)>,
     Unfolding: (\ s :: CryptTools.HexString ->
                 case Text.Read.readEither6
                        @ GHC.Integer.Type.Integer
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Integer.Type.Integer
                           CryptTools.readB3
                           (GHC.CString.unpackAppendCString#
                              "0x"#
                              (case s of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                               Data.ByteString.Internal.$wunpackAppendCharsLazy
                                 ww1
                                 ww2
                                 ww3
                                 ww4
                                 (GHC.Types.[] @ GHC.Types.Char) }))) of wild {
                   [] -> CryptTools.readB2
                   : x ds
                   -> case ds of wild1 {
                        [] -> x : ipv ipv1 -> CryptTools.readB1 } }) -}
c530c87e61111488b1a274b37a88a0a8
  readB2 :: GHC.Integer.Type.Integer
  {- Strictness: b -}
c7633ec186c0772fa66669fe48cc1906
  readB3 :: Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: ((GHC.Read.$fReadInteger3
                    GHC.Read.$fReadInteger_$sconvertInt
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                      <GHC.Integer.Type.Integer>_R)
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither5 @ GHC.Integer.Type.Integer)) -}
76aa7ca571e7ac594fd7e5942e47cc62
  showB1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 6) -}
b2db6620c086746be30ea90c5497df3d
  showB16 :: GHC.Integer.Type.Integer -> CryptTools.HexString
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ i :: GHC.Integer.Type.Integer ->
                 let {
                   cs :: [GHC.Types.Char]
                   = Numeric.showIntAtBase
                       @ GHC.Integer.Type.Integer
                       GHC.Real.$fIntegralInteger
                       GHC.Show.$fShowInteger
                       Numeric.showHex1
                       GHC.Show.intToDigit
                       i
                       (GHC.Types.[] @ GHC.Types.Char)
                 } in
                 Data.ByteString.Internal.unsafePackLenChars
                   (case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 })
                   cs) -}
f27e8c16b344ec97d5d830fafb31aa28
  showB2 :: GHC.Integer.Type.Integer -> GHC.Types.Char
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Integer.Type.Integer ->
                 case GHC.List.lookup
                        @ GHC.Types.Int
                        @ GHC.Types.Char
                        GHC.Classes.$fEqInt
                        (GHC.Num.$fNumInt_$cfromInteger x)
                        CryptTools.b64ListMap of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                   GHC.Base.Just x1 -> x1 }) -}
a25bab07bd9ee80c45ae6be5f1660382
  showB64 :: GHC.Integer.Type.Integer -> CryptTools.B64String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ n2 :: GHC.Integer.Type.Integer ->
                 let {
                   cs :: [GHC.Types.Char]
                   = GHC.Base.map
                       @ GHC.Integer.Type.Integer
                       @ GHC.Types.Char
                       CryptTools.showB2
                       (GHC.List.reverse1
                          @ GHC.Integer.Type.Integer
                          (CryptTools.showB64_splitBits' CryptTools.showB1 n2)
                          (GHC.Types.[] @ GHC.Integer.Type.Integer))
                 } in
                 Data.ByteString.Internal.unsafePackLenChars
                   (case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 })
                   cs) -}
6e9147fd40b49b837ef08be230909281
  showB64String :: [GHC.Word.Word8] -> CryptTools.B64String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Word.Word8] ->
                 case GHC.List.$wlenAcc @ GHC.Word.Word8 s 0 of ww2 { DEFAULT ->
                 case GHC.Classes.modInt# ww2 3 of ww1 {
                   DEFAULT
                   -> let {
                        ws :: [GHC.Word.Word8]
                        = case CryptTools.showB64
                                 (CryptTools.joinBits_$sjoinBits
                                    CryptTools.showB64String1
                                    (GHC.Base.++
                                       @ GHC.Word.Word8
                                       s
                                       (let {
                                          y :: GHC.Prim.Int# = GHC.Prim.-# 3 ww1
                                        } in
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.<# 0 y) of wild {
                                          GHC.Types.False -> GHC.Types.[] @ GHC.Word.Word8
                                          GHC.Types.True
                                          -> CryptTools.$wxs1
                                               y }))) of ww { Data.ByteString.Internal.PS ww3 ww4 ww5 ww6 ->
                          let {
                            t :: [GHC.Word.Word8]
                            = Data.ByteString.Internal.$wunpackAppendBytesLazy
                                ww3
                                ww4
                                ww5
                                ww6
                                (GHC.Types.[] @ GHC.Word.Word8)
                          } in
                          case GHC.List.$wlenAcc @ GHC.Word.Word8 t 0 of ww7 { DEFAULT ->
                          let {
                            y :: GHC.Prim.Int# = GHC.Prim.-# ww7 (GHC.Prim.-# 3 ww1)
                          } in
                          let {
                            n2 :: [GHC.Word.Word8]
                            = let {
                                y1 :: GHC.Prim.Int# = GHC.Prim.-# 3 ww1
                              } in
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# 0 y1) of wild {
                                GHC.Types.False -> GHC.Types.[] @ GHC.Word.Word8
                                GHC.Types.True -> CryptTools.$wxs y1 }
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0 y) of wild {
                            GHC.Types.False -> n2
                            GHC.Types.True
                            -> letrec {
                                 $wgo1 :: [GHC.Word.Word8] -> GHC.Prim.Int# -> [GHC.Word.Word8]
                                   {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                                 = \ w :: [GHC.Word.Word8] ww8 :: GHC.Prim.Int# ->
                                   case w of wild1 {
                                     [] -> n2
                                     : y1 ys
                                     -> case ww8 of ds1 {
                                          DEFAULT
                                          -> GHC.Types.:
                                               @ GHC.Word.Word8
                                               y1
                                               ($wgo1 ys (GHC.Prim.-# ds1 1))
                                          1 -> GHC.Types.: @ GHC.Word.Word8 y1 n2 } }
                               } in
                               $wgo1 t y } } }
                      } in
                      Data.ByteString.Internal.unsafePackLenBytes
                        (case GHC.List.$wlenAcc @ GHC.Word.Word8 ws 0 of ww3 { DEFAULT ->
                         GHC.Types.I# ww3 })
                        ws
                   0
                   -> CryptTools.showB64
                        (CryptTools.joinBits_$sjoinBits
                           CryptTools.showB64String1
                           s) } }) -}
233eddd8a1d7796dc73709739c407ed6
  showB64String1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8) -}
62e3ef7232bfa6726d7c98fef90fdd31
  showB64_splitBits' ::
    GHC.Types.Int
    -> GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <L,U(U)><S,U> -}
24a6601e69e6f9ec543369f45721a80c
  showBin ::
    (GHC.Real.Integral a, GHC.Show.Show a) => a -> GHC.Base.String
  {- Arity: 3,
     Strictness: <S(SLLLLLC(C(S))LL),U(U(U(U,U,U,U,U,U,U),U,U),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: (\ @ a3
                   $dIntegral :: GHC.Real.Integral a3
                   $dShow :: GHC.Show.Show a3
                   eta :: a3 ->
                 Numeric.showIntAtBase
                   @ a3
                   $dIntegral
                   $dShow
                   (GHC.Num.fromInteger
                      @ a3
                      (GHC.Real.$p1Real @ a3 (GHC.Real.$p1Integral @ a3 $dIntegral))
                      CryptTools.showBin1)
                   GHC.Show.intToDigit
                   eta
                   (GHC.Types.[] @ GHC.Types.Char)) -}
65d0db798e07a99e733aac2c8e82513e
  showBin1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 2) -}
e0dd5ba7113cd62291bf3e9d45e1fd5e
  similarity :: GHC.Real.Integral a => [a] -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,A,A,A,A,C(U))><S,1*U><L,U>,
     Unfolding: (\ @ a3
                   $dIntegral :: GHC.Real.Integral a3
                   eta :: [a3]
                   eta1 :: [a3] ->
                 let {
                   $dReal :: GHC.Real.Real a3 = GHC.Real.$p1Integral @ a3 $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a3 = GHC.Real.$p1Real @ a3 $dReal
                 } in
                 let {
                   k :: a3 -> a3 -> a3 = GHC.Num.+ @ a3 $dNum
                 } in
                 let {
                   a4 :: a3 -> a3 -> a3 = GHC.Num.* @ a3 $dNum
                 } in
                 let {
                   ds :: a3
                   = let {
                       k1 :: a3 -> a3 -> a3 = GHC.Num.+ @ a3 $dNum
                     } in
                     letrec {
                       go1 :: [a3] -> a3 -> a3 {- Arity: 2, Strictness: <S,1*U><L,U> -}
                       = \ ds1 :: [a3] eta2 :: a3 ->
                         case ds1 of wild { [] -> eta2 : y ys -> go1 ys (k1 eta2 y) }
                     } in
                     go1 eta1 (GHC.Num.fromInteger @ a3 $dNum CryptTools.joinBits1)
                 } in
                 letrec {
                   go1 :: [a3] -> [a3] -> a3 -> a3
                     {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                   = \ ds1 :: [a3] eta2 :: [a3] eta3 :: a3 ->
                     case ds1 of wild {
                       [] -> eta3
                       : y ys
                       -> case eta2 of wild1 {
                            [] -> eta3
                            : y1 ys1
                            -> go1 ys ys1 (k eta3 (a4 (GHC.Num.* @ a3 $dNum y ds) y1)) } }
                 } in
                 go1
                   eta
                   (GHC.Base.map
                      @ a3
                      @ a3
                      (GHC.Real.fromIntegral @ a3 @ a3 $dIntegral $dNum)
                      eta1)
                   (GHC.Num.fromInteger @ a3 $dNum CryptTools.joinBits1)) -}
7ca3425f7636e325535f119a2485e9f3
  splitBits ::
    (GHC.Num.Num a, Data.Bits.Bits a) => GHC.Types.Int -> a -> [a]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A)><L,U(U)><L,U>,
     Unfolding: (\ @ a3
                   $dNum :: GHC.Num.Num a3
                   $dBits :: Data.Bits.Bits a3
                   bs :: GHC.Types.Int
                   number :: a3 ->
                 let {
                   lvl3 :: a3 = GHC.Num.fromInteger @ a3 $dNum CryptTools.joinBits1
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq a3 = Data.Bits.$p1Bits @ a3 $dBits
                 } in
                 letrec {
                   splitBits' :: GHC.Types.Int -> a3 -> [a3]
                     {- Arity: 2, Strictness: <L,U(U)><L,U> -}
                   = \ ds :: GHC.Types.Int ds1 :: a3 ->
                     case GHC.Classes.== @ a3 $dEq ds1 lvl3 of wild {
                       GHC.Types.False
                       -> GHC.Types.:
                            @ a3
                            (Data.Bits..&.
                               @ a3
                               $dBits
                               (GHC.Num.fromInteger
                                  @ a3
                                  $dNum
                                  (case ds of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case x of wild3 {
                                          DEFAULT
                                          -> GHC.Integer.Type.minusInteger
                                               (GHC.Real.$wf CryptTools.showBin1 wild3)
                                               CryptTools.splitBits1
                                          0 -> CryptTools.joinBits1 }
                                     GHC.Types.True -> GHC.Real.^1 } }))
                               ds1)
                            (splitBits' ds (Data.Bits.shiftR @ a3 $dBits ds1 ds))
                       GHC.Types.True -> GHC.Types.[] @ a3 }
                 } in
                 GHC.List.reverse1
                   @ a3
                   (splitBits' bs number)
                   (GHC.Types.[] @ a3)) -}
a28a26398079ddde04d02fe912a51304
  splitBits1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
e550ccb7293f23e21137a468a8e5dd10
  xorChar :: Data.Bits.Bits a => [a] -> a -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a3 $dBits :: Data.Bits.Bits a3 bitlist :: [a3] bit :: a3 ->
                 GHC.Base.build
                   @ a3
                   (\ @ b1 c :: a3 -> b1 -> b1[OneShot] n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ a3
                      @ b1
                      (GHC.Base.mapFB @ a3 @ b1 @ a3 c (Data.Bits.xor @ a3 $dBits bit))
                      n2
                      bitlist)) -}
"SPEC joinBits @ Word8 @ Integer" [ALWAYS] forall $dIntegral :: GHC.Real.Integral
                                                                  GHC.Word.Word8
                                                  $dNum :: GHC.Num.Num GHC.Integer.Type.Integer
                                                  $dBits :: Data.Bits.Bits GHC.Integer.Type.Integer
  CryptTools.joinBits @ GHC.Word.Word8
                      @ GHC.Integer.Type.Integer
                      $dIntegral
                      $dNum
                      $dBits
  = CryptTools.joinBits_$sjoinBits
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

