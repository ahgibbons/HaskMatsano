
==================== FINAL INTERFACE ====================
2016-06-02 10:22:30.3596428 UTC

interface Matas_5owQ4W1svNRDGggvsHH52l:CryptTools 7103
  interface hash: 67f0f540a9a7ebae1dc18b2c8621fd14
  ABI hash: 0c8532d7a30789eab9d7fdff54db04c0
  export-list hash: 8166248ba896b1ade28c63dfa1bce64f
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ca90f50df6a523fc5f8156d8564fb914
  sig of: Nothing
  used TH splices: False
  where
exports:
  CryptTools.b64List
  CryptTools.b64ListMap
  CryptTools.b64ListMapFlip
  CryptTools.charCountVector
  CryptTools.countChars
  CryptTools.hexToString
  CryptTools.joinBits
  CryptTools.letterFreqs
  CryptTools.letterPerc
  CryptTools.mSplitAt
  CryptTools.padd
  CryptTools.readB16
  CryptTools.showB16
  CryptTools.showB64
  CryptTools.showB64String
  CryptTools.showBin
  CryptTools.similarity
  CryptTools.splitBits
  CryptTools.stringToHex
  CryptTools.xorB16
  CryptTools.xorChar
  CryptTools.xorCharBS
  CryptTools.B64String
  CryptTools.HexString
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 bitwise-0.1.1.1@bitwi_1UInExT1dkGBFQ7JfumA61
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      types-compat-0.1.1@types_4nbjkueFGIp963bsRkjZLR
                      word8-0.1.2@word8_6yKBsGbmsbLB2UCORShr75
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics base-4.8.2.0:GHC.TypeLits
                         bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW:Data.ByteString.Read.Class
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Bits 87f514c5f0e66e224843da33c04aa38b
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Numeric 7a5febcdaefe4560a31129dafeb9ee43
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  bitwise-0.1.1.1@bitwi_1UInExT1dkGBFQ7JfumA61:Data.Bits.Bitwise ccee56f8d406d69f235a496d42447bb2
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString 0ddef3e8d5f0e8e432c4b23b5632df49
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Char8 0e05dff95094adf61a7e5b18e5656265
import  -/  bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Internal d42248609eb9fca89eb019a632739209
import  -/  bytestring-read-0.3.1@bytes_E70YK5o9wd6F4IFwPKQNVW:Data.ByteString.Read aac2566c5a3fd0b72a616937cbc2f1e7
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Strict 835c6fadc5446acd8356b2317fd91a15
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 906b37a40029a8b67c803fa4b303a827
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
import  -/  word8-0.1.2@word8_6yKBsGbmsbLB2UCORShr75:Data.Word8 a01147ba26a2bfc60193452ee1b281ba
3c7ce11ef7312e43e6805e1fff66fe44
  $wgo :: [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
23d78ed8c3264440d73a23e7bebd7554
  $wgo1 ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U>,
     Inline: [0] -}
9549da8ba2519d2e8b045eec18c59233
  $whexToString ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.ByteString.Internal.ByteString
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>, Inline: [0] -}
8336371a47ebb27058e526b7203bb6f7
  $wmSplitAt ::
    GHC.Types.Int
    -> GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe
         (Data.ByteString.Internal.ByteString,
          Data.ByteString.Internal.ByteString)
  {- Arity: 5, Strictness: <L,1*U(U)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   ww :: GHC.Prim.Addr#
                   ww1 :: GHC.ForeignPtr.ForeignPtrContents
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int# ->
                 case CryptTools.mSplitAt1 of wild1 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                 let {
                   $j :: GHC.Prim.Void#
                         -> GHC.Base.Maybe
                              (Data.ByteString.Internal.ByteString,
                               Data.ByteString.Internal.ByteString)
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ w1 :: GHC.Prim.Void#[OneShot] ->
                     GHC.Base.Just
                       @ (Data.ByteString.Internal.ByteString,
                          Data.ByteString.Internal.ByteString)
                       (case w of wild2 { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# x 0) of wild3 {
                          GHC.Types.False
                          -> case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x ww3) of wild4 {
                               GHC.Types.False
                               -> (Data.ByteString.Internal.PS ww ww1 ww2 x,
                                   Data.ByteString.Internal.PS
                                     ww
                                     ww1
                                     (GHC.Prim.+# ww2 x)
                                     (GHC.Prim.-# ww3 x))
                               GHC.Types.True
                               -> (Data.ByteString.Internal.PS ww ww1 ww2 ww3,
                                   Data.ByteString.empty) }
                          GHC.Types.True
                          -> (Data.ByteString.empty,
                              Data.ByteString.Internal.PS ww ww1 ww2 ww3) } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim./=# ww3 dt7) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqAddr# ww dt4) of wild {
                        GHC.Types.False
                        -> case Data.ByteString.Internal.$wcompareBytes
                                  ww
                                  ww1
                                  ww2
                                  ww3
                                  dt4
                                  dt5
                                  dt6
                                  dt7 of wild4 {
                             DEFAULT -> $j GHC.Prim.void#
                             GHC.Types.EQ
                             -> GHC.Base.Nothing
                                  @ (Data.ByteString.Internal.ByteString,
                                     Data.ByteString.Internal.ByteString) }
                        GHC.Types.True
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 dt6) of wild3 {
                             GHC.Types.False
                             -> case Data.ByteString.Internal.$wcompareBytes
                                       ww
                                       ww1
                                       ww2
                                       ww3
                                       dt4
                                       dt5
                                       dt6
                                       dt7 of wild4 {
                                  DEFAULT -> $j GHC.Prim.void#
                                  GHC.Types.EQ
                                  -> GHC.Base.Nothing
                                       @ (Data.ByteString.Internal.ByteString,
                                          Data.ByteString.Internal.ByteString) }
                             GHC.Types.True
                             -> GHC.Base.Nothing
                                  @ (Data.ByteString.Internal.ByteString,
                                     Data.ByteString.Internal.ByteString) } }
                   GHC.Types.True -> $j GHC.Prim.void# } }) -}
e1b7d01e38625ae7dada885428ac2bff
  $wpadd :: a -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a3 w :: a3 ww :: GHC.Prim.Int# w1 :: [a3] ->
                 let {
                   $j :: GHC.Prim.Int# -> [a3] {- Arity: 1, Strictness: <S,1*U> -}
                   = \ x :: GHC.Prim.Int#[OneShot] ->
                     case x of wild {
                       DEFAULT
                       -> let {
                            y :: GHC.Prim.Int# = GHC.Prim.-# ww wild
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0 y) of wild1 {
                            GHC.Types.False -> w1
                            GHC.Types.True
                            -> let {
                                 lvl8 :: [a3] = GHC.Types.: @ a3 w w1
                               } in
                               letrec {
                                 $wxs2 :: GHC.Prim.Int# -> [a3]
                                   {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                 = \ ww1 :: GHC.Prim.Int# ->
                                   case ww1 of ds1 {
                                     DEFAULT -> GHC.Types.: @ a3 w ($wxs2 (GHC.Prim.-# ds1 1))
                                     1 -> lvl8 }
                               } in
                               $wxs2 y }
                       0 -> w1 }
                 } in
                 case ww of wild {
                   DEFAULT
                   -> case GHC.List.$wlenAcc @ a3 w1 0 of ww2 { DEFAULT ->
                      case GHC.Classes.modInt# ww2 wild of ww1 { DEFAULT -> $j ww1 } }
                   (-1) -> $j 0
                   0 -> case GHC.Real.divZeroError ret_ty [a3] of {} }) -}
9f0bedc738548135f64f6719313fc0e8
  $wsimilarity ::
    GHC.Real.Integral a =>
    [GHC.Types.Double] -> [a] -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U))><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a3
                   w :: GHC.Real.Integral a3
                   w1 :: [GHC.Types.Double]
                   w2 :: [a3] ->
                 CryptTools.$wgo1
                   w1
                   (let {
                      testVect' :: [GHC.Types.Double]
                      = GHC.Base.map
                          @ a3
                          @ GHC.Types.Double
                          (\ eta :: a3 ->
                           case GHC.Integer.Type.doubleFromInteger
                                  (GHC.Real.toInteger @ a3 w eta) of wild { DEFAULT ->
                           GHC.Types.D# wild })
                          w2
                    } in
                    GHC.Base.map
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      (let {
                         ds :: GHC.Types.Double
                         = case CryptTools.$wgo testVect' 0.0 of ww { DEFAULT ->
                           GHC.Types.D# ww }
                       } in
                       \ ds1 :: GHC.Types.Double -> GHC.Float.divideDouble ds1 ds)
                      testVect')
                   0.0) -}
fac3b350eb938285ed7bedd2cc9026ca
  $wstringToHex ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.ByteString.Internal.ByteString
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Addr#
                   ww1 :: GHC.ForeignPtr.ForeignPtrContents
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int# ->
                 letrec {
                   $wgo4 :: GHC.Prim.Addr#
                            -> GHC.Prim.Addr# -> [Data.ByteString.Internal.ByteString]
                     {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
                   = \ ww4 :: GHC.Prim.Addr# ww5 :: GHC.Prim.Addr# ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.eqAddr# ww4 ww5) of wild1 {
                       GHC.Types.False
                       -> case GHC.Prim.readWord8OffAddr#
                                 @ GHC.Prim.RealWorld
                                 ww4
                                 0
                                 GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                          case GHC.Prim.touch#
                                 @ GHC.ForeignPtr.ForeignPtrContents
                                 ww1
                                 ipv of s' { DEFAULT ->
                          GHC.Types.:
                            @ Data.ByteString.Internal.ByteString
                            (let {
                               cs :: [GHC.Types.Char]
                               = Numeric.showIntAtBase
                                   @ GHC.Integer.Type.Integer
                                   GHC.Real.$fIntegralInteger
                                   GHC.Show.$fShowInteger
                                   Numeric.showHex1
                                   GHC.Show.intToDigit
                                   (GHC.Integer.Type.smallInteger (GHC.Prim.word2Int# ipv1))
                                   (GHC.Types.[] @ GHC.Types.Char)
                             } in
                             Data.ByteString.Internal.unsafePackLenChars
                               (case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww6 { DEFAULT ->
                                GHC.Types.I# ww6 })
                               cs)
                            ($wgo4 (GHC.Prim.plusAddr# ww4 1) ww5) } }
                       GHC.Types.True
                       -> GHC.Types.[] @ Data.ByteString.Internal.ByteString }
                 } in
                 Data.ByteString.Internal.$fMonoidByteString_$cmconcat
                   ($wgo4
                      (GHC.Prim.plusAddr# ww ww2)
                      (GHC.Prim.plusAddr# ww (GHC.Prim.+# ww2 ww3)))) -}
5b14d998691935c11f497d36b8f867f0
  $wxorCharBS ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Word.Word8
    -> Data.ByteString.Internal.ByteString
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Addr#
                   ww1 :: GHC.ForeignPtr.ForeignPtrContents
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   w :: GHC.Word.Word8 ->
                 letrec {
                   $wa :: GHC.Prim.Int#
                          -> GHC.Prim.Addr#
                          -> GHC.Prim.Addr#
                          -> GHC.Prim.State# GHC.Prim.RealWorld
                          -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>, Inline: [0] -}
                   = \ ww4 :: GHC.Prim.Int#
                       ww5 :: GHC.Prim.Addr#
                       ww6 :: GHC.Prim.Addr#
                       w1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ww4 ww3) of wild1 {
                       GHC.Types.False
                       -> case GHC.Prim.readWord8OffAddr#
                                 @ GHC.Prim.RealWorld
                                 (GHC.Prim.plusAddr# ww5 ww4)
                                 0
                                 w1 of ds2 { (#,#) ipv ipv1 ->
                          case w of wild { GHC.Word.W8# x# ->
                          case GHC.Prim.writeWord8OffAddr#
                                 @ GHC.Prim.RealWorld
                                 (GHC.Prim.plusAddr# ww6 ww4)
                                 0
                                 (GHC.Prim.xor# x# ipv1)
                                 ipv of s2 { DEFAULT ->
                          $wa (GHC.Prim.+# ww4 1) ww5 ww6 s2 } } }
                       GHC.Types.True -> (# w1, GHC.Tuple.() #) }
                 } in
                 GHC.IO.unsafeDupablePerformIO
                   @ Data.ByteString.Internal.ByteString
                   (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<# ww3 0) of wild1 {
                      GHC.Types.False
                      -> case GHC.Prim.newPinnedByteArray#
                                @ GHC.Prim.RealWorld
                                ww3
                                s of ds { (#,#) ipv ipv1 ->
                         let {
                           a3 :: GHC.Prim.Addr#
                           = GHC.Prim.byteArrayContents#
                               ipv1
                                 `cast`
                               (UnivCo mkUnsafeCo representational (GHC.Prim.MutableByteArray#
                                                                      GHC.Prim.RealWorld) GHC.Prim.ByteArray#)
                         } in
                         case $wa
                                0
                                (GHC.Prim.plusAddr# ww ww2)
                                a3
                                ipv of ds1 { (#,#) ipv2 ipv3 ->
                         let {
                           a4 :: GHC.ForeignPtr.ForeignPtrContents
                           = GHC.ForeignPtr.PlainPtr ipv1
                         } in
                         case GHC.Prim.touch#
                                @ GHC.ForeignPtr.ForeignPtrContents
                                a4
                                ipv2 of s' { DEFAULT ->
                         case GHC.Prim.touch#
                                @ GHC.ForeignPtr.ForeignPtrContents
                                ww1
                                s' of s'1 { DEFAULT ->
                         (# s'1, Data.ByteString.Internal.PS a3 a4 0 ww3 #) } } } }
                      GHC.Types.True
                      -> case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                         ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                   Data.ByteString.Internal.ByteString #)
                         of {} })
                     `cast`
                   (Sym (GHC.Types.NTCo:IO[0]
                             <Data.ByteString.Internal.ByteString>_R))) -}
753cf457c32423a0278aa8959dde676d
  $wxs :: GHC.Prim.Int# -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
6bfc243239a069a5f4c18ead2f55a65e
  $wxs1 :: GHC.Prim.Int# -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
9ec2b83420e2a247306fc38f1f6c7bc1
  type B64String = Data.ByteString.Internal.ByteString
c506429768d9bc3ee1cd98b8780c2bde
  type HexString = Data.ByteString.Internal.ByteString
01a84fdb3cdfa0933288b273de4b6cf3
  b64List :: [GHC.Types.Char]
  {- Unfolding: (CryptTools.b64List_go 65) -}
f5e7e9a6ce9947ff29220bd33859ae95
  b64ListMap :: [(GHC.Types.Int, GHC.Types.Char)]
  {- Unfolding: (CryptTools.b64ListMap_go 0 CryptTools.b64List) -}
4639d327b9e2754a919b013d69bc3a51
  b64ListMapFlip :: [(GHC.Types.Char, GHC.Types.Int)]
  {- Unfolding: (GHC.List.zip
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   CryptTools.b64List
                   CryptTools.b64ListMapFlip1) -}
1f5d03d09ee55d6b5c32ff4bacd81023
  b64ListMapFlip1 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0 9223372036854775807) -}
531236722272b81baa5a6700c3763a28
  b64ListMap_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Char] -> [(GHC.Types.Int, GHC.Types.Char)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
7f89c7762d6b8070de755c57d2c8147c
  b64List_go :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,U> -}
4d8698cbd4227b8b27274f1843a38c71
  charCountVector ::
    GHC.Base.String
    -> [(GHC.Types.Char, GHC.Types.Int)] -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ alphabet :: GHC.Base.String
                   charCount :: [(GHC.Types.Char, GHC.Types.Int)] ->
                 GHC.Base.map
                   @ GHC.Types.Char
                   @ GHC.Types.Int
                   (\ y :: GHC.Types.Char ->
                    case GHC.List.lookup
                           @ GHC.Types.Char
                           @ GHC.Types.Int
                           GHC.Classes.$fEqChar
                           y
                           charCount of wild {
                      GHC.Base.Nothing -> CryptTools.charCountVector1
                      GHC.Base.Just n2 -> n2 })
                   alphabet) -}
f6108ad48b557617397f944401c8976b
  charCountVector1 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0) -}
b8f9b691b39cf5d2fe322300d1bc5fdf
  countChars ::
    GHC.Base.String
    -> GHC.Base.String -> [(GHC.Types.Char, GHC.Types.Int)]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ alphabet :: GHC.Base.String
                   string :: GHC.Base.String ->
                 GHC.Base.map
                   @ [GHC.Types.Char]
                   @ (GHC.Types.Char, GHC.Types.Int)
                   CryptTools.countChars1
                   (Data.OldList.groupBy
                      @ GHC.Types.Char
                      GHC.Classes.$fEqChar_$c==
                      (Data.OldList.sortBy
                         @ GHC.Types.Char
                         GHC.Classes.$fOrdChar_$ccompare
                         (GHC.List.filter
                            @ GHC.Types.Char
                            (\ ds :: GHC.Types.Char ->
                             GHC.List.elem @ GHC.Types.Char GHC.Classes.$fEqChar ds alphabet)
                            string)))) -}
f127fe61d3c6efba49c0def79c5990fc
  countChars1 :: [GHC.Types.Char] -> (GHC.Types.Char, GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ cs :: [GHC.Types.Char] ->
                 (GHC.List.head @ GHC.Types.Char cs,
                  case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                  GHC.Types.I# ww2 })) -}
c6be5855143e78bc1dd0dda205d32631
  hexToString ::
    CryptTools.HexString -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: CryptTools.HexString ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 CryptTools.$whexToString ww1 ww2 ww3 ww4 }) -}
5bc21fe86c69d92cab6a1b1f5851ef44
  joinBits ::
    (GHC.Real.Integral a, GHC.Num.Num b, Data.Bits.Bits b) =>
    GHC.Types.Int -> [a] -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><L,U(A,A,1*U,A,A,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U)><S,U>,
     Unfolding: (\ @ a3
                   @ b
                   $dIntegral :: GHC.Real.Integral a3
                   $dNum :: GHC.Num.Num b
                   $dBits :: Data.Bits.Bits b
                   byteshift :: GHC.Types.Int
                   wlist :: [a3] ->
                 case GHC.List.$wlenAcc @ a3 wlist 0 of ww2 { DEFAULT ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww2 1
                 } in
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 2
                 } in
                 let {
                   a4 :: b -> b -> b = Data.Bits..|. @ b $dBits
                 } in
                 let {
                   z :: b = GHC.Num.fromInteger @ b $dNum CryptTools.joinBits1
                 } in
                 let {
                   c :: GHC.Types.Int -> ([a3] -> b) -> [a3] -> b
                     {- Arity: 3, Strictness: <L,1*U(U)><L,1*C1(U)><S,1*U> -}
                   = \ _x :: GHC.Types.Int _r :: [a3] -> b[OneShot] ds :: [a3] ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> a4
                            (Data.Bits.shift
                               @ b
                               $dBits
                               (GHC.Num.fromInteger
                                  @ b
                                  $dNum
                                  (GHC.Real.toInteger @ a3 $dIntegral y))
                               (case byteshift of wild1 { GHC.Types.I# x ->
                                case _x of wild2 { GHC.Types.I# y1 ->
                                GHC.Types.I# (GHC.Prim.*# x y1) } }))
                            (_r ys) }
                 } in
                 let {
                   n2 :: [a3] -> b
                     {- Arity: 1, Strictness: <L,A>,
                        Unfolding: InlineRule (1, True, True) (\ ds :: [a3] -> z) -}
                   = \ ds :: [a3] -> z
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x2 x1) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB @ ([a3] -> b) c n2 x1 x2 0 wlist
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB @ ([a3] -> b) c n2 x1 x2 0 wlist } }) -}
6319311f190c644790b900dabaa8f32c
  joinBits1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
63ace67a296efd1a8b647318e38f3c26
  joinBits_$sjoinBits ::
    GHC.Types.Int -> [GHC.Word.Word8] -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,U(U)><S,U>,
     Unfolding: (\ byteshift :: GHC.Types.Int
                   wlist :: [GHC.Word.Word8] ->
                 case GHC.List.$wlenAcc @ GHC.Word.Word8 wlist 0 of ww2 { DEFAULT ->
                 let {
                   x1 :: GHC.Prim.Int# = GHC.Prim.-# ww2 1
                 } in
                 let {
                   x2 :: GHC.Prim.Int# = GHC.Prim.-# ww2 2
                 } in
                 let {
                   c :: GHC.Types.Int
                        -> ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        -> [GHC.Word.Word8]
                        -> GHC.Integer.Type.Integer
                     {- Arity: 3, Strictness: <L,1*U(U)><L,1*C1(U)><S,1*U> -}
                   = \ _x :: GHC.Types.Int
                       _r :: [GHC.Word.Word8] -> GHC.Integer.Type.Integer[OneShot]
                       ds :: [GHC.Word.Word8] ->
                     case ds of wild {
                       [] -> CryptTools.joinBits1
                       : y ys
                       -> case y of wild1 { GHC.Word.W8# x# ->
                          case byteshift of wild2 { GHC.Types.I# x ->
                          case _x of wild3 { GHC.Types.I# y1 ->
                          let {
                            ww :: GHC.Prim.Int# = GHC.Prim.*# x y1
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# ww 0) of wild4 {
                            GHC.Types.False
                            -> GHC.Integer.Type.orInteger
                                 (GHC.Integer.Type.shiftRInteger
                                    (GHC.Integer.Type.smallInteger (GHC.Prim.word2Int# x#))
                                    (GHC.Prim.negateInt# ww))
                                 (_r ys)
                            GHC.Types.True
                            -> GHC.Integer.Type.orInteger
                                 (GHC.Integer.Type.shiftLInteger
                                    (GHC.Integer.Type.smallInteger (GHC.Prim.word2Int# x#))
                                    ww)
                                 (_r ys) } } } } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x2 x1) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        c
                        CryptTools.joinBits_n
                        x1
                        x2
                        0
                        wlist
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ ([GHC.Word.Word8] -> GHC.Integer.Type.Integer)
                        c
                        CryptTools.joinBits_n
                        x1
                        x2
                        0
                        wlist } }) -}
d788a3fce8bae590dbfa44d82b7c09b4
  joinBits_n :: [GHC.Word.Word8] -> GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: [GHC.Word.Word8] -> CryptTools.joinBits1) -}
636f4dd79111fa7f425889d3458c51ef
  letterFreqs :: [(GHC.Types.Char, GHC.Types.Double)]
  {- Unfolding: (CryptTools.letterFreqs_go
                   97
                   CryptTools.letterPerc) -}
fb0df8ff6a1f3b3ac120da5bc9763810
  letterFreqs_go ::
    GHC.Prim.Int#
    -> [GHC.Types.Double] -> [(GHC.Types.Char, GHC.Types.Double)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U> -}
fcbb644b8203c7679e73d974b2b93393
  letterPerc :: [GHC.Types.Double]
  {- Unfolding: (GHC.Base.map
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   CryptTools.letterPerc53
                   CryptTools.letterPerc1) -}
aac1c7f2d6fd02658bb2127f709c0abd
  letterPerc1 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc52
                   CryptTools.letterPerc2) -}
bd4bc80b4b60088c2e725ae1e67c1031
  letterPerc10 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc43
                   CryptTools.letterPerc11) -}
cf3dd61d01eeb4109cfdd3ab55d5ad8c
  letterPerc11 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc42
                   CryptTools.letterPerc12) -}
d684f74913440a2e3fbe4c78c1365ce2
  letterPerc12 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc41
                   CryptTools.letterPerc13) -}
06240f62fde0a2a16fc0c326cc29fa2f
  letterPerc13 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc40
                   CryptTools.letterPerc14) -}
ba21a8050b5ebc7d669c40d2895d79c0
  letterPerc14 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc39
                   CryptTools.letterPerc15) -}
863694985276016c35f18f65a98bc44d
  letterPerc15 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc38
                   CryptTools.letterPerc16) -}
8e2e439bb02a8cb228a8cf60d4ecab49
  letterPerc16 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc37
                   CryptTools.letterPerc17) -}
2014d1617f32ff0f3e5a61c1964a5508
  letterPerc17 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc36
                   CryptTools.letterPerc18) -}
ccfcf348af2c2e4f88919a1130f9b49d
  letterPerc18 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc35
                   CryptTools.letterPerc19) -}
88c6a1adf73d0d28249d7376d728a9c0
  letterPerc19 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc34
                   CryptTools.letterPerc20) -}
85be0a34a9b51f28d9ab65bbf8d69425
  letterPerc2 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc51
                   CryptTools.letterPerc3) -}
4cbb191118e9bf84e86ede6c85a11c77
  letterPerc20 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc33
                   CryptTools.letterPerc21) -}
81484c571dde788ccbcf08c19081e911
  letterPerc21 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc32
                   CryptTools.letterPerc22) -}
19c40722235b408e9d3ed1c9a48746f4
  letterPerc22 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc31
                   CryptTools.letterPerc23) -}
342108959ccbd119bbcb3fb957333a13
  letterPerc23 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc30
                   CryptTools.letterPerc24) -}
86b7905821bcf8bc33be51372838a083
  letterPerc24 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc29
                   CryptTools.letterPerc25) -}
a82ba5158d1afc3609aca7af2debe2e4
  letterPerc25 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc28
                   CryptTools.letterPerc26) -}
607adef6040f918825553d75cff106f7
  letterPerc26 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc27
                   (GHC.Types.[] @ GHC.Types.Double)) -}
517701e57f1aee60ce5ffcfbf18ffbf0
  letterPerc27 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 7.4e-2) -}
a55b4632a4c06ef3aa6c0c0784403dd4
  letterPerc28 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.974) -}
2121d6431ac6cda582e9ae3f1ae92f45
  letterPerc29 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.15) -}
65f34ebee83c038a90cf8c7b89db5ef3
  letterPerc3 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc50
                   CryptTools.letterPerc4) -}
71e63667154ed0321664a20465064a0f
  letterPerc30 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.361) -}
dc3a06f8d8ffb537d486ac035f6d7fe6
  letterPerc31 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.978) -}
2b3357414a1079a816112c6313d29c37
  letterPerc32 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.758) -}
bf45675847869344d47e42bc6519c182
  letterPerc33 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 9.056) -}
698f718c10c1253c7fe1166ec85bbe4e
  letterPerc34 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.327) -}
5089fd91763858d12bd2f55958453d70
  letterPerc35 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 5.987) -}
133a7997a47e4b134ab0c6e3e8ba88e6
  letterPerc36 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 9.5e-2) -}
ef9c8c765f51c5ab4523a7866d53f03b
  letterPerc37 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.929) -}
95d9a5a4c413228e5f49bf365d799e80
  letterPerc38 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 7.507) -}
406a7785e14ef3ff7dfc045319a67220
  letterPerc39 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.749) -}
3150f0dd709f2284d0156be8e703463e
  letterPerc4 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc49
                   CryptTools.letterPerc5) -}
a1ca6031ae112b0950990daebfc28bbd
  letterPerc40 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.406) -}
042419fa6bb27247f9718e31dc32bc7c
  letterPerc41 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 4.025) -}
ad2e778369152323eed987796a23b846
  letterPerc42 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.772) -}
59253b2db51a439d0e6fb3d77d04353f
  letterPerc43 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.153) -}
992b6ad1d688b91cdc989f8861d11cfa
  letterPerc44 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.966) -}
350804ac846bdbc5a85ab7ee690c3725
  letterPerc45 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 6.094) -}
c6cbf9b67cbb1b17c88bdf3f1350f9ed
  letterPerc46 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.015) -}
c1f00147da1b1584800f387faa31fbca
  letterPerc47 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.228) -}
e7b09e24c2e5a79dd9bd63a7472526d2
  letterPerc48 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 12.702) -}
f17f5311f3f1376dd0ea88fe4ca55672
  letterPerc49 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 4.253) -}
269daf33aa276bee20bf9697d1a24e60
  letterPerc5 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc48
                   CryptTools.letterPerc6) -}
4dc50855852001d4247eee32a129bf25
  letterPerc50 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 2.782) -}
89a5aa976ddca088f66fe81c3b130da8
  letterPerc51 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.492) -}
c9e5a7b5bb6912f2f694d69081155912
  letterPerc52 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 8.167) -}
efe2075b90f2d32b914241a8754ca60b
  letterPerc53 :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ ds :: GHC.Types.Double ->
                 case ds of wild { GHC.Types.D# x ->
                 GHC.Types.D# (GHC.Prim./## x 100.0) }) -}
dd814073d785cd63cb51c9082c86c01a
  letterPerc6 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc47
                   CryptTools.letterPerc7) -}
27e7478112910b65b8ed1aef9eb9703e
  letterPerc7 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc46
                   CryptTools.letterPerc8) -}
9d92538d235dac451197afc2b6da9336
  letterPerc8 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc45
                   CryptTools.letterPerc9) -}
0163a0a7aee0f065775ea8bcf68519dc
  letterPerc9 :: [GHC.Types.Double]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   CryptTools.letterPerc44
                   CryptTools.letterPerc10) -}
2c6b7ca7e499ed1377c611c4f18ca62e
  mSplitAt ::
    GHC.Types.Int
    -> Data.ByteString.Internal.ByteString
    -> GHC.Base.Maybe
         (Data.ByteString.Internal.ByteString,
          Data.ByteString.Internal.ByteString)
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Data.ByteString.Internal.ByteString ->
                 case w1 of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 CryptTools.$wmSplitAt w ww1 ww2 ww3 ww4 }) -}
b9bb86ffafc41a543eb05c4890461558
  mSplitAt1 :: Data.ByteString.Internal.ByteString
  {- Unfolding: (Data.ByteString.Internal.unsafePackLenChars
                   CryptTools.mSplitAt2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f6649b6710742253988b2e4e6af578cb
  mSplitAt2 :: GHC.Types.Int
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        (GHC.Types.[] @ GHC.Types.Char)
                        0 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 }) -}
af8e7954632c706de5b5b380b3d688aa
  padd :: a -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 3, Strictness: <L,U><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a3 w :: a3 w1 :: GHC.Types.Int w2 :: [a3] ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 CryptTools.$wpadd @ a3 w ww1 w2 }) -}
37650592b38587495c675abfb764bf12
  readB16 :: CryptTools.HexString -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <L,1*U(U,U,U,U)>,
     Unfolding: (\ s :: CryptTools.HexString ->
                 case Text.Read.readEither6
                        @ GHC.Integer.Type.Integer
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Integer.Type.Integer
                           ((GHC.Read.$fReadInteger3
                               GHC.Read.$fReadInteger_$sconvertInt
                               Text.ParserCombinators.ReadPrec.minPrec)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                 <GHC.Integer.Type.Integer>_R)
                              @ GHC.Integer.Type.Integer
                              (Text.Read.readEither5 @ GHC.Integer.Type.Integer))
                           (GHC.CString.unpackAppendCString#
                              "0x"#
                              (case s of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                               Data.ByteString.Internal.$wunpackAppendCharsLazy
                                 ww1
                                 ww2
                                 ww3
                                 ww4
                                 (GHC.Types.[] @ GHC.Types.Char) }))) of wild {
                   []
                   -> GHC.Err.error @ GHC.Integer.Type.Integer Text.Read.readEither4
                   : x ds
                   -> case ds of wild1 {
                        [] -> x
                        : ipv ipv1
                        -> GHC.Err.error
                             @ GHC.Integer.Type.Integer
                             Text.Read.readEither2 } }) -}
fba8d5c79460a588418790ddc15aba6f
  showB1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 6) -}
9d20275bb7cbb0159d1f5a444c4f396a
  showB16 :: GHC.Integer.Type.Integer -> CryptTools.HexString
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ i :: GHC.Integer.Type.Integer ->
                 let {
                   cs :: [GHC.Types.Char]
                   = Numeric.showIntAtBase
                       @ GHC.Integer.Type.Integer
                       GHC.Real.$fIntegralInteger
                       GHC.Show.$fShowInteger
                       Numeric.showHex1
                       GHC.Show.intToDigit
                       i
                       (GHC.Types.[] @ GHC.Types.Char)
                 } in
                 Data.ByteString.Internal.unsafePackLenChars
                   (case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 })
                   cs) -}
4e0e1ea54a98e3faeb443d1fc11bf3b9
  showB2 :: GHC.Integer.Type.Integer -> GHC.Types.Char
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Integer.Type.Integer ->
                 case GHC.List.lookup
                        @ GHC.Types.Int
                        @ GHC.Types.Char
                        GHC.Classes.$fEqInt
                        (GHC.Num.$fNumInt_$cfromInteger x)
                        CryptTools.b64ListMap of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Char
                   GHC.Base.Just x1 -> x1 }) -}
b2644b351462551abc690880d82634b0
  showB64 :: GHC.Integer.Type.Integer -> CryptTools.B64String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ n2 :: GHC.Integer.Type.Integer ->
                 let {
                   cs :: [GHC.Types.Char]
                   = GHC.Base.map
                       @ GHC.Integer.Type.Integer
                       @ GHC.Types.Char
                       CryptTools.showB2
                       (GHC.List.reverse1
                          @ GHC.Integer.Type.Integer
                          (CryptTools.showB64_splitBits' CryptTools.showB1 n2)
                          (GHC.Types.[] @ GHC.Integer.Type.Integer))
                 } in
                 Data.ByteString.Internal.unsafePackLenChars
                   (case GHC.List.$wlenAcc @ GHC.Types.Char cs 0 of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 })
                   cs) -}
2d84ccd2bf17ba152d7e7d517f9bc6fa
  showB64String :: [GHC.Word.Word8] -> CryptTools.B64String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Word.Word8] ->
                 case GHC.List.$wlenAcc @ GHC.Word.Word8 s 0 of ww2 { DEFAULT ->
                 case GHC.Classes.modInt# ww2 3 of ww1 {
                   DEFAULT
                   -> let {
                        ws :: [GHC.Word.Word8]
                        = case CryptTools.showB64
                                 (CryptTools.joinBits_$sjoinBits
                                    CryptTools.showB64String1
                                    (GHC.Base.++
                                       @ GHC.Word.Word8
                                       s
                                       (let {
                                          y :: GHC.Prim.Int# = GHC.Prim.-# 3 ww1
                                        } in
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.<# 0 y) of wild {
                                          GHC.Types.False -> GHC.Types.[] @ GHC.Word.Word8
                                          GHC.Types.True
                                          -> CryptTools.$wxs1
                                               y }))) of ww { Data.ByteString.Internal.PS ww3 ww4 ww5 ww6 ->
                          let {
                            t :: [GHC.Word.Word8]
                            = Data.ByteString.Internal.$wunpackAppendBytesLazy
                                ww3
                                ww4
                                ww5
                                ww6
                                (GHC.Types.[] @ GHC.Word.Word8)
                          } in
                          case GHC.List.$wlenAcc @ GHC.Word.Word8 t 0 of ww7 { DEFAULT ->
                          let {
                            y :: GHC.Prim.Int# = GHC.Prim.-# ww7 (GHC.Prim.-# 3 ww1)
                          } in
                          let {
                            n2 :: [GHC.Word.Word8]
                            = let {
                                y1 :: GHC.Prim.Int# = GHC.Prim.-# 3 ww1
                              } in
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# 0 y1) of wild {
                                GHC.Types.False -> GHC.Types.[] @ GHC.Word.Word8
                                GHC.Types.True -> CryptTools.$wxs y1 }
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# 0 y) of wild {
                            GHC.Types.False -> n2
                            GHC.Types.True
                            -> letrec {
                                 $wgo4 :: [GHC.Word.Word8] -> GHC.Prim.Int# -> [GHC.Word.Word8]
                                   {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                                 = \ w :: [GHC.Word.Word8] ww8 :: GHC.Prim.Int# ->
                                   case w of wild1 {
                                     [] -> n2
                                     : y1 ys
                                     -> case ww8 of ds1 {
                                          DEFAULT
                                          -> GHC.Types.:
                                               @ GHC.Word.Word8
                                               y1
                                               ($wgo4 ys (GHC.Prim.-# ds1 1))
                                          1 -> GHC.Types.: @ GHC.Word.Word8 y1 n2 } }
                               } in
                               $wgo4 t y } } }
                      } in
                      Data.ByteString.Internal.unsafePackLenBytes
                        (case GHC.List.$wlenAcc @ GHC.Word.Word8 ws 0 of ww3 { DEFAULT ->
                         GHC.Types.I# ww3 })
                        ws
                   0
                   -> CryptTools.showB64
                        (CryptTools.joinBits_$sjoinBits
                           CryptTools.showB64String1
                           s) } }) -}
81da1f062d019d8300584fee455624ac
  showB64String1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8) -}
965e46ccbf013209c02ef6d358096f61
  showB64_splitBits' ::
    GHC.Types.Int
    -> GHC.Integer.Type.Integer -> [GHC.Integer.Type.Integer]
  {- Arity: 2, Strictness: <L,U(U)><S,U> -}
4070cac9770d5c4a30f37ce130032e7d
  showBin ::
    (GHC.Real.Integral a, GHC.Show.Show a) => a -> GHC.Base.String
  {- Arity: 3,
     Strictness: <S(SLLLLLC(C(S))LL),U(U(U(U,U,U,U,U,U,U),U,U),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: (\ @ a3
                   $dIntegral :: GHC.Real.Integral a3
                   $dShow :: GHC.Show.Show a3
                   eta :: a3 ->
                 Numeric.showIntAtBase
                   @ a3
                   $dIntegral
                   $dShow
                   (GHC.Num.fromInteger
                      @ a3
                      (GHC.Real.$p1Real @ a3 (GHC.Real.$p1Integral @ a3 $dIntegral))
                      CryptTools.showBin1)
                   GHC.Show.intToDigit
                   eta
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8a40f9893e7abaaa995d4c916c39526d
  showBin1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 2) -}
d435e7c7a2876118ee7ca5d91dc01deb
  similarity ::
    GHC.Real.Integral a =>
    [GHC.Types.Double] -> [a] -> GHC.Types.Double
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U))><S,1*U><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a3
                   w :: GHC.Real.Integral a3
                   w1 :: [GHC.Types.Double]
                   w2 :: [a3] ->
                 case CryptTools.$wsimilarity @ a3 w w1 w2 of ww { DEFAULT ->
                 GHC.Types.D# ww }) -}
181601b3530db173022d8d26b449a63d
  splitBits ::
    (GHC.Num.Num a, Data.Bits.Bits a) => GHC.Types.Int -> a -> [a]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,C(C1(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(C1(U)),A,A,A,A)><L,U(U)><L,U>,
     Unfolding: (\ @ a3
                   $dNum :: GHC.Num.Num a3
                   $dBits :: Data.Bits.Bits a3
                   bs :: GHC.Types.Int
                   number :: a3 ->
                 let {
                   lvl8 :: a3 = GHC.Num.fromInteger @ a3 $dNum CryptTools.joinBits1
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq a3 = Data.Bits.$p1Bits @ a3 $dBits
                 } in
                 letrec {
                   splitBits' :: GHC.Types.Int -> a3 -> [a3]
                     {- Arity: 2, Strictness: <L,U(U)><L,U> -}
                   = \ ds :: GHC.Types.Int ds1 :: a3 ->
                     case GHC.Classes.== @ a3 $dEq ds1 lvl8 of wild {
                       GHC.Types.False
                       -> GHC.Types.:
                            @ a3
                            (Data.Bits..&.
                               @ a3
                               $dBits
                               (GHC.Num.fromInteger
                                  @ a3
                                  $dNum
                                  (case ds of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case x of wild3 {
                                          DEFAULT
                                          -> GHC.Integer.Type.minusInteger
                                               (GHC.Real.$wf CryptTools.showBin1 wild3)
                                               CryptTools.splitBits1
                                          0 -> CryptTools.joinBits1 }
                                     GHC.Types.True -> GHC.Real.^1 } }))
                               ds1)
                            (splitBits' ds (Data.Bits.shiftR @ a3 $dBits ds1 ds))
                       GHC.Types.True -> GHC.Types.[] @ a3 }
                 } in
                 GHC.List.reverse1
                   @ a3
                   (splitBits' bs number)
                   (GHC.Types.[] @ a3)) -}
3f1f6d4e3c87e1d1fa857b07eb1e0b4a
  splitBits1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
5e31941607e3f110608da6f17b2cb4ff
  stringToHex ::
    Data.ByteString.Internal.ByteString -> CryptTools.HexString
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Data.ByteString.Internal.ByteString ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 CryptTools.$wstringToHex ww1 ww2 ww3 ww4 }) -}
d41f58c2674938dec4a9391cad4b4107
  xorB16 ::
    CryptTools.HexString
    -> CryptTools.HexString -> CryptTools.HexString
  {- Arity: 2, Strictness: <L,1*U(U,U,U,U)><L,1*U(U,U,U,U)> -}
41542e2f8160b691ddbe372c1b2e4718
  xorChar :: Data.Bits.Bits a => [a] -> a -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C1(C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a3 $dBits :: Data.Bits.Bits a3 bitlist :: [a3] bit :: a3 ->
                 GHC.Base.build
                   @ a3
                   (\ @ b1 c :: a3 -> b1 -> b1[OneShot] n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ a3
                      @ b1
                      (GHC.Base.mapFB @ a3 @ b1 @ a3 c (Data.Bits.xor @ a3 $dBits bit))
                      n2
                      bitlist)) -}
47bcfd35f27ad77ccf05dd8e26d9f8f9
  xorCharBS ::
    Data.ByteString.Internal.ByteString
    -> GHC.Word.Word8 -> Data.ByteString.Internal.ByteString
  {- Arity: 2, Strictness: <S,1*U(U,U,U,U)><L,U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Data.ByteString.Internal.ByteString w1 :: GHC.Word.Word8 ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 CryptTools.$wxorCharBS ww1 ww2 ww3 ww4 w1 }) -}
"SPEC joinBits @ Word8 @ Integer" [ALWAYS] forall $dIntegral :: GHC.Real.Integral
                                                                  GHC.Word.Word8
                                                  $dNum :: GHC.Num.Num GHC.Integer.Type.Integer
                                                  $dBits :: Data.Bits.Bits GHC.Integer.Type.Integer
  CryptTools.joinBits @ GHC.Word.Word8
                      @ GHC.Integer.Type.Integer
                      $dIntegral
                      $dNum
                      $dBits
  = CryptTools.joinBits_$sjoinBits
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

